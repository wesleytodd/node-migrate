#!/usr/bin/env node
// vim: set ft=javascript:
'use strict'

var program = require('commander')
var path = require('path')
var minimatch = require('minimatch')
var migrate = require('../')
var runMigrations = require('../lib/migrate')
var positionOfMigration = require('../lib/position-of-migration')
var runMigrationMethod = require('../lib/run-migration-method')
var log = require('../lib/log')
var registerCompiler = require('../lib/register-compiler')
var pkg = require('../package.json')

program
  .version(pkg.version)
  .usage('[options] <name>')
  .option('-c, --chdir <dir>', 'Change the working directory', process.cwd())
  .option('-f, --state-file <path>', 'Set path to state file', '.migrate')
  .option('-s, --store <store>', 'Set the migrations store', path.join(__dirname, '..', 'lib', 'file-store'))
  .option('--force', 'Force through the command, ignoring warnings')
  .option('--migrations-dir <dir>', 'Change the migrations directory name', 'migrations')
  .option('--matches <glob>', 'A glob pattern to filter migration files', '*')
  .option('--compiler <ext:module>', 'Use the given module to compile files')
  .parse(process.argv)

// Check clean flag, exit if NODE_ENV === 'production' and force not specified
if (program.clean && process.env.NODE_ENV === 'production' && !program.force) {
  log.error('error', 'Cowardly refusing to clean while node environment set to production, use --force to continue.')
  process.exit(1)
}

// Check init flag, exit if NODE_ENV === 'production' and force not specified
if (program.init && process.env.NODE_ENV === 'production' && !program.force) {
  log.error('error', 'Cowardly refusing to init while node environment set to production, use --force to continue.')
  process.exit(1)
}

if (!program.args[0]) {
  log.error('error', 'migrate test requires a migration name to test')
  process.exit(1)
}

// Change the working dir
process.chdir(program.chdir)

// Load compiler
if (program.compiler) {
  registerCompiler(program.compiler)
}

// Setup store
var Store = require(program.store)
var store = new Store(program.stateFile)

// Load migrations
migrate.load({
  stateStore: store,
  migrationsDirectory: program.migrationsDir,
  filterFunction: minimatch.filter(program.matches)
}, function (err, set) {
  if (err) {
    log.error('error', err)
    process.exit(1)
  }

  // Position of migration
  var migrationName = program.args[0]
  var pos = positionOfMigration(set, migrationName)

  // If migration position is -1 no migration matched,
  // exit with error
  if (pos === -1) {
    log.error('error', 'No migration named ' + migrationName)
    process.exit(1)
  }

  // Migration one before the one we are testing
  var prevMigration = set.migrations[pos - 1]
  var prevTitle = prevMigration && prevMigration.title

  set.on('warning', function (msg) {
    log('warning', msg)
  })

  set.on('migration', function (migration, direction) {
    log(direction, migration.title)
  })

  runMigrations(set, 'down', null, function (err) {
    if (err) {
      log('error', err)
      process.exit(1)
    }

    ;(prevTitle ? runMigrations : runNoop)(set, 'up', prevTitle, function (err) {
      if (err) {
        log('error', err)
        process.exit(1)
      }
      runMigrationMethod(set.migrations[pos], 'test', function (err) {
        if (err) {
          log('error', err)
          process.exit(1)
        }
        log('success', 'Ran test on ' + migrationName)
      })
    })
  })
})

function runNoop (set, dir, title, fn) {
  fn()
}
